# -*- coding: utf-8 -*-
"""time sharing.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1zi7b1PF7v9sHqTZE_8GfOzO_fNLpdumd
"""

#!/usr/bin/env python
# coding: utf-8

import numpy as np
import pandas as pd
import yfinance as yf
import matplotlib.pyplot as plt
import warnings
from statsmodels.tsa.arima.model import ARIMA
import statsmodels.api as sm
import statsmodels.tsa.api as smt
from sklearn.metrics import mean_squared_error
from statsmodels.tsa.stattools import adfuller, acf, pacf
from statsmodels.tsa.seasonal import seasonal_decompose

warnings.filterwarnings('ignore')
plt.style.use('ggplot')

def get_aapl_data():
    """
    Get AAPL stock data either from Yahoo Finance or use built-in sample data
    """
    try:
        # Try to download from Yahoo Finance
        data = yf.download('AAPL', start='2020-01-01', end='2023-12-31', progress=False)
        if not data.empty:
            data = data.reset_index()  # Reset index to make Date a column
            data = data[['Date', 'Close']]  # Keep only Date and Close columns
            print("Successfully downloaded AAPL data from Yahoo Finance")
            return data
    except Exception as e:
        print(f"Error downloading data: {e}")

    # Fallback to sample data if download fails
    print("Using sample data instead")
    date_range = pd.date_range(start='2020-01-01', end='2023-12-31')
    np.random.seed(42)
    base_price = 100 + np.random.uniform(0, 100)
    prices = base_price + np.cumsum(np.random.normal(0, 1, len(date_range)))

    data = pd.DataFrame({
        'Date': date_range,
        'Close': prices
    })
    return data

def test_stationarity(timeseries):
    """Perform Dickey-Fuller test for stationarity"""
    print('Results of Dickey-Fuller Test:')
    print("==============================================")

    dftest = adfuller(timeseries, autolag='AIC')
    dfoutput = pd.Series(dftest[0:4], index=['Test Statistic', 'p-value', '#lags Used', 'Number of Observations Used'])

    for key, value in dftest[4].items():
        dfoutput['Critical Value (%s)'%key] = value

    print(dfoutput)
    return dfoutput

def plot_rolling_stats(timeseries, window=365):
    """Plot rolling statistics"""
    rolmean = timeseries.rolling(window=window).mean()
    rolstd = timeseries.rolling(window=window).std()

    plt.figure(figsize=(12, 6))
    orig = plt.plot(timeseries, color='blue', label='Original')
    mean = plt.plot(rolmean, color='red', label='Rolling Mean')
    std = plt.plot(rolstd, color='black', label='Rolling Std')
    plt.legend(loc='best')
    plt.title('Rolling Mean & Standard Deviation')
    plt.show()

def main():
    # Get the data
    df = get_aapl_data()
    print("\nFirst 3 rows of data:")
    print(df.head(3))

    # Basic data info
    print("\nData Description:")
    print(df.describe())
    print("\nData Types:")
    print(df.dtypes)

    # Setting the Date as Index
    df_ts = df.set_index('Date')
    df_ts.sort_index(inplace=True)
    print("\nTime Series Data (first 3):")
    print(df_ts.head(3))
    print("\nTime Series Data (last 3):")
    print(df_ts.tail(3))

    # Check for missing values
    print("\nMissing values count:", len(df_ts[df_ts.isnull()]))
    df_ts.Close.fillna(method='pad', inplace=True)
    print("After filling NA:", len(df_ts[df_ts.Close.isnull()]))

    # Plot original data
    df_ts.plot(figsize=(12, 6), title='AAPL Closing Prices')
    plt.show()

    # Stationarity tests
    ts = df_ts['Close']
    print("\nInitial Stationarity Test:")
    test_stationarity(ts)

    # Rolling statistics plot
    plot_rolling_stats(ts)

    # Log transformation
    ts_log = np.log(ts)
    plt.figure(figsize=(12, 6))
    plt.plot(ts_log, label='Log Transformed')
    plt.title('Log Transformed Series')
    plt.legend()
    plt.show()

    # Moving average
    moving_avg = ts_log.rolling(window=12).mean()
    plt.figure(figsize=(12, 6))
    plt.plot(ts_log, label='Original')
    plt.plot(moving_avg, color='red', label='Moving Average')
    plt.legend()
    plt.show()

    # Remove moving average
    ts_log_ma = ts_log - moving_avg
    ts_log_ma.dropna(inplace=True)
    print("\nStationarity after removing MA:")
    test_stationarity(ts_log_ma)

    # Exponential weighted moving average
    expw_ma = ts_log.ewm(halflife=12, min_periods=0, adjust=True).mean()
    plt.figure(figsize=(12, 6))
    plt.plot(ts_log, label='Original')
    plt.plot(expw_ma, color='red', label='EWMA')
    plt.legend()
    plt.show()

    # Differencing
    ts_log_diff = ts_log - ts_log.shift()
    plt.figure(figsize=(12, 6))
    plt.plot(ts_log_diff)
    plt.title('Differenced Series')
    plt.show()

    ts_log_diff.dropna(inplace=True)
    print("\nStationarity after differencing:")
    test_stationarity(ts_log_diff)

    # Decomposition
    decomposition = seasonal_decompose(ts_log, period=30)
    trend = decomposition.trend
    seasonal = decomposition.seasonal
    residual = decomposition.resid

    plt.figure(figsize=(12, 8))
    plt.subplot(411)
    plt.plot(ts_log, label='Original')
    plt.legend(loc='best')
    plt.subplot(412)
    plt.plot(trend, label='Trend')
    plt.legend(loc='best')
    plt.subplot(413)
    plt.plot(seasonal, label='Seasonality')
    plt.legend(loc='best')
    plt.subplot(414)
    plt.plot(residual, label='Residuals')
    plt.legend(loc='best')
    plt.tight_layout()
    plt.show()

    # ACF and PACF plots
    lag_acf = acf(ts_log_diff, nlags=20)
    lag_pacf = pacf(ts_log_diff, nlags=20, method='ols')

    plt.figure(figsize=(12, 6))
    plt.subplot(121)
    plt.plot(lag_acf)
    plt.axhline(y=0, linestyle='--', color='gray')
    plt.axhline(y=-1.96/np.sqrt(len(ts_log_diff)), linestyle='--', color='gray')
    plt.axhline(y=1.96/np.sqrt(len(ts_log_diff)), linestyle='--', color='gray')
    plt.title('Autocorrelation Function')

    plt.subplot(122)
    plt.plot(lag_pacf)
    plt.axhline(y=0, linestyle='--', color='gray')
    plt.axhline(y=-1.96/np.sqrt(len(ts_log_diff)), linestyle='--', color='gray')
    plt.axhline(y=1.96/np.sqrt(len(ts_log_diff)), linestyle='--', color='gray')
    plt.title('Partial Autocorrelation Function')
    plt.tight_layout()
    plt.show()

    # ARIMA Model
    model = ARIMA(ts_log, order=(1,1,1))
    results_AR = model.fit()
    plt.figure(figsize=(12, 6))
    plt.plot(ts_log_diff)
    plt.plot(results_AR.fittedvalues, color='red')
    plt.title('RSS: %.4f'% sum((results_AR.fittedvalues-ts_log_diff)**2))
    plt.show()

    # Make predictions
    predictions_ARIMA_diff = pd.Series(results_AR.fittedvalues, copy=True)
    predictions_ARIMA_diff_cumsum = predictions_ARIMA_diff.cumsum()

    predictions_ARIMA_log = pd.Series(ts_log.iloc[0], index=ts_log.index)
    predictions_ARIMA_log = predictions_ARIMA_log.add(predictions_ARIMA_diff_cumsum, fill_value=0)

    predictions_ARIMA = np.exp(predictions_ARIMA_log)
    plt.figure(figsize=(12, 6))
    plt.plot(ts, label='Actual')
    plt.plot(predictions_ARIMA, label='Predicted')
    plt.title('Actual vs Predicted')
    plt.legend()
    plt.show()

    # Forecast future values
    forecast_steps = 30
    forecast = results_AR.get_forecast(steps=forecast_steps)
    forecast_index = pd.date_range(ts.index[-1], periods=forecast_steps+1, freq='D')[1:]
    forecast_values = np.exp(forecast.predicted_mean)

    plt.figure(figsize=(12, 6))
    plt.plot(ts, label='Historical')
    plt.plot(forecast_index, forecast_values, color='red', label='Forecast')
    plt.title(f'{forecast_steps}-Day Price Forecast')
    plt.legend()
    plt.show()

    print("\nForecasted values:")
    print(pd.DataFrame({
        'Date': forecast_index,
        'Forecasted_Price': forecast_values
    }).head())

if __name__ == "__main__":
    main()